% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen-nn-functional-docs.R,
%   R/gen-nn-functional-examples.R
\name{nnf_grid_sample}
\alias{nnf_grid_sample}
\title{Grid_sample}
\arguments{
\item{input}{(Tensor) input of shape \eqn{(N, C, H_\text{in}, W_\text{in})} (4-D case)                    or \eqn{(N, C, D_\text{in}, H_\text{in}, W_\text{in})} (5-D case)}

\item{grid}{(Tensor) flow-field of shape \eqn{(N, H_\text{out}, W_\text{out}, 2)} (4-D case)                   or \eqn{(N, D_\text{out}, H_\text{out}, W_\text{out}, 3)} (5-D case)}

\item{mode}{(str) interpolation mode to calculate output values        \code{'bilinear'} | \code{'nearest'}. Default: \code{'bilinear'}}

\item{padding_mode}{(str) padding mode for outside grid values        \code{'zeros'} | \code{'border'} | \code{'reflection'}. Default: \code{'zeros'}}

\item{align_corners}{(bool, optional) Geometrically, we consider the pixels of the        input  as squares rather than points.        If set to \code{True}, the extrema (\code{-1} and \code{1}) are considered as referring        to the center points of the input's corner pixels. If set to \code{False}, they        are instead considered as referring to the corner points of the input's corner        pixels, making the sampling more resolution agnostic.        This option parallels the \code{align_corners} option in        \code{\link{interpolate}}, and so whichever option is used here        should also be used there to resize the input image before grid sampling.        Default: \code{False}}
}
\description{
Given an \code{input} and a flow-field \code{grid}, computes the
\code{output} using \code{input} values and pixel locations from \code{grid}.
}
\details{
\preformatted{Currently, only spatial (4-D) and volumetric (5-D) `input` are
supported.

In the spatial (4-D) case, for `input` with shape
\eqn{(N, C, H_\text{in}, W_\text{in})} and `grid` with shape
\eqn{(N, H_\text{out}, W_\text{out}, 2)}, the output will have shape
\eqn{(N, C, H_\text{out}, W_\text{out})}.

For each output location ``output[n, :, h, w]``, the size-2 vector
``grid[n, h, w]`` specifies `input` pixel locations ``x`` and ``y``,
which are used to interpolate the output value ``output[n, :, h, w]``.
In the case of 5D inputs, ``grid[n, d, h, w]`` specifies the
``x``, ``y``, ``z`` pixel locations for interpolating
``output[n, :, d, h, w]``. `mode` argument specifies ``nearest`` or
``bilinear`` interpolation method to sample the input pixels.

`grid` specifies the sampling pixel locations normalized by the
`input` spatial dimensions. Therefore, it should have most values in
the range of ``[-1, 1]``. For example, values ``x = -1, y = -1`` is the
left-top pixel of `input`, and values  ``x = 1, y = 1`` is the
right-bottom pixel of `input`.

If `grid` has values outside the range of ``[-1, 1]``, the corresponding
outputs are handled as defined by `padding_mode`. Options are

    * ``padding_mode="zeros"``: use ``0`` for out-of-bound grid locations,
    * ``padding_mode="border"``: use border values for out-of-bound grid locations,
    * ``padding_mode="reflection"``: use values at locations reflected by
      the border for out-of-bound grid locations. For location far away
      from the border, it will keep being reflected until becoming in bound,
      e.g., (normalized) pixel location ``x = -3.5`` reflects by border ``-1``
      and becomes ``x' = 1.5``, then reflects by border ``1`` and becomes
      ``x'' = -0.5``.

.. note::
    This function is often used in conjunction with [`affine_grid`]
    to build `Spatial Transformer Networks`_ .
.. include:: cuda_deterministic_backward.rst
}
}
\examples{


}
